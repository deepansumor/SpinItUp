{"version":3,"file":"spinitup.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;UCVA;UACA;;;;;WCDA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,QAAQ,WAAW;AAClC,gBAAgB,OAAO;AACvB;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW,eAAe,gBAAgB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,6BAA6B;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,wCAAwC,wCAAwC;AAChF;AACA;AACA,yBAAyB;AACzB,uBAAuB,oBAAoB,IAAI;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,+CAA+C,sCAAsC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uBAAuB,EAAE,sBAAsB,KAAK,qBAAqB;AAChH;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,+CAA+C,uBAAuB,wBAAwB;AAC9F;AACA;AACA,oCAAoC,mCAAmC;AACvE;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ,QAAQ;AAC/B;AACA,4BAA4B;AAC5B;AACA,0CAA0C,gCAAgC;AAC1E;AACA;AACA,C","sources":["webpack://SpinItUp/webpack/universalModuleDefinition","webpack://SpinItUp/webpack/bootstrap","webpack://SpinItUp/webpack/runtime/define property getters","webpack://SpinItUp/webpack/runtime/hasOwnProperty shorthand","webpack://SpinItUp/webpack/runtime/make namespace object","webpack://SpinItUp/./lib/spinitup.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SpinItUp\"] = factory();\n\telse\n\t\troot[\"SpinItUp\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\r\n * SpinItUp: A customizable Spin-the-Wheel class.\r\n * Author: Deepansu Mor (https://github.com/deepansumor)\r\n */\r\n\r\nexport default class SpinItUp {\r\n    /**\r\n     * Initializes the SpinItUp instance with the provided element and options.\r\n     * @param {HTMLElement} elem - The HTML element representing the wheel.\r\n     * @param {Object} [options={}] - Configuration options for the spin.\r\n     * @throws {Error} - If the provided element is not a valid HTMLElement.\r\n     */\r\n    constructor(elem, options = {}) {\r\n        if (!(elem instanceof HTMLElement)) {\r\n            throw new Error('Element is not a valid HTMLElement');\r\n        }\r\n\r\n        this.elem = elem;\r\n\r\n        // Define possible states\r\n        this.states = {\r\n            SPINNING: 'spinning',\r\n            STOPPED: 'stopped',\r\n            FINISHED: 'finished',\r\n            ERROR: 'error',\r\n        };\r\n\r\n        // Default options and user-provided overrides\r\n        this.options = {\r\n            spins: 2, // Number of full rotations\r\n            easing: 'linear', // Animation easing\r\n            callback: (type, data) => console.log(type, data), // Default callback function\r\n            segments: Array.from({ length: 6 }, (_, i) => ({ segment: i + 1 })), // Default segments\r\n            stopAt: null, // Winning segment index or function returning the stop segment\r\n            direction: 'clockwise', // Spin direction\r\n            rotate: 0,\r\n            ...options,\r\n        };\r\n\r\n        if (!this.options.segments[this.options.stopAt - 1]) {\r\n            throw new Error(`stopAt must be a valid Number within the segments array 1 - ${this.options.segments.length}`);\r\n        }\r\n\r\n        this.directions = ['clockwise', 'anti-clockwise'];\r\n\r\n        this.options.duration = this.options.duration;\r\n        this.state = this.states.STOPPED;\r\n        this.style();\r\n\r\n        this.options.rotate = +this.options.rotate || 0;\r\n        this.elem.style.transform = `rotate(${this.options.rotate}deg)`;\r\n    }\r\n\r\n    /**\r\n     * Updates the stop angle for the winning segment.\r\n     */\r\n    updateStopAngle() {\r\n        const slice = 360 / this.options.segments.length;\r\n        this.stopAngle = this.minMax(\r\n            this.options.stopAt * slice - slice + 10,\r\n            this.options.stopAt * slice - 10\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Generates a random number between the given minimum and maximum values.\r\n     * @param {number} min - The minimum value.\r\n     * @param {number} max - The maximum value.\r\n     * @returns {number} - A random number within the range.\r\n     */\r\n    minMax(min, max) {\r\n        return Math.floor(Math.random() * (max - min + 1) + min);\r\n    }\r\n\r\n    /**\r\n     * Generates the CSS keyframe animation for the spinning effect.\r\n     */\r\n    style() {\r\n        this.updateStopAngle();\r\n\r\n        let deg = 360 * this.options.spins;\r\n        if (!this.directions.includes(this.options.direction)) {\r\n            this.options.direction = 'clockwise';\r\n        }\r\n\r\n        if (this.options.direction === \"random\") {\r\n            const randomIndex = Math.floor(Math.random() * this.directions.length);\r\n            this.options.direction = this.directions[randomIndex];\r\n        }\r\n\r\n        if (this.options.direction === \"clockwise\") {\r\n            deg = deg + (360 - this.stopAngle);\r\n        } else if (this.options.direction === \"anti-clockwise\") {\r\n            deg = -(deg + this.stopAngle);\r\n        }\r\n\r\n        this.options.speed = deg / this.options.duration;\r\n\r\n        this.spinAnimationKey = `spin-${Math.random().toString(36).substring(7)}`;\r\n        const style = document.createElement('style');\r\n        style.innerHTML = `\r\n            @keyframes ${this.spinAnimationKey} {\r\n                100% { transform: rotate(${deg}deg); }\r\n            }\r\n        `;\r\n        document.head.appendChild(style);\r\n    }\r\n\r\n    /**\r\n     * Starts the spinning process.\r\n     * @returns {void}\r\n     */\r\n    async start() {\r\n        if (this.state !== this.states.STOPPED) {\r\n            return this.callback(this.state, { message: 'Wheel is already spinning' });\r\n        }\r\n        this.state = this.states.SPINNING;\r\n        this.#spin();\r\n    }\r\n\r\n    /**\r\n     * Internal method to handle the spinning animation.\r\n     * @private\r\n     */\r\n    #spin() {\r\n        this.style();\r\n        this.callback(this.state);\r\n        this.elem.style.animation = `${this.spinAnimationKey} ${this.options.duration}ms ${this.options.easing} 1 forwards`;\r\n        setTimeout(() => this.stop(), this.options.duration);\r\n    }\r\n\r\n    /**\r\n     * Stops the spinning and determines the winning segment.\r\n     * @returns {void}\r\n     */\r\n    stop() {\r\n        if (this.state !== this.states.SPINNING) {\r\n            return this.callback(this.state, { message: 'Cannot stop; wheel is not spinning' });\r\n        }\r\n        this.state = this.states.FINISHED;\r\n        this.callback(this.state, { segment: this.getWinningSegment() });\r\n    }\r\n\r\n    /**\r\n     * Resets the spin wheel to its initial state.\r\n     * @returns {void}\r\n     */\r\n    reset() {\r\n        this.state = this.states.STOPPED;\r\n        this.elem.style.animation = 'none';\r\n        this.callback(this.state);\r\n    }\r\n\r\n    /**\r\n     * Retrieves the winning segment based on the stop angle.\r\n     * @returns {Object} - The winning segment.\r\n     */\r\n    getWinningSegment() {\r\n        return this.options.segments[this.options.stopAt - 1];\r\n    }\r\n\r\n    /**\r\n     * Executes the callback function with the provided type and data.\r\n     * @param {string} type - The type of the event (e.g., spinning, stopped).\r\n     * @param {Object} [data={}] - Additional data to pass to the callback.\r\n     */\r\n    callback(type, data = {}) {\r\n        if (typeof this.options.callback === 'function') {\r\n            this.options.callback(type, { ...data, timestamp: Date.now() });\r\n        }\r\n    }\r\n}"],"names":[],"sourceRoot":""}