{"version":3,"file":"spinitup.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;;ACVqC;AACrC;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA,QAAQ,oDAAQ;AAChB;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,mEAAmE;AACnE,6FAA6F;AAC7F,wCAAwC;AACxC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,mBAAmB;AAClC,eAAe,QAAQ;AACvB,eAAe,cAAc;AAC7B,iBAAiB,aAAa;AAC9B;AACA;AACA,QAAQ,oDAAQ;AAChB;AACA;AACA;AACA,wDAAwD;AACxD,uDAAuD;AACvD,6DAA6D;AAC7D;AACA;AACA;AACA,YAAY,oDAAQ;AACpB,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oDAAQ,6BAA6B,YAAY;AACjE;AACA;AACA;AACA;AACA,QAAQ,oDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA,QAAQ,oDAAQ;AAChB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC;AACtC,kCAAkC;AAClC,4BAA4B;AAC5B,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,mCAAmC;AACnC,0CAA0C;AAC1C,oCAAoC;AACpC,uCAAuC;AACvC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iDAAiD;AACjD,0CAA0C;AAC1C,oDAAoD;AACpD,uCAAuC;AACvC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oDAAQ;AAChB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,8BAA8B;AAC9B,iCAAiC;AACjC;AACA;AACA;AACA;AACA,QAAQ,oDAAQ,mCAAmC,WAAW;AAC9D;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvO+B;AACA;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW,eAAe,gBAAgB;AAC7E;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wCAAwC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,MAAgC,IAAI,IAAU;AACxE;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA,kBAAkB,SAAS,GAAG,KAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gCAAgC,iDAAK;AACrC,uBAAuB,iDAAK;AAC5B;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAK;AACrC,uBAAuB,iDAAK;AAC5B;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yCAAyC,OAAO,oBAAoB,IAAI,SAAS;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,6BAA6B;AACxH;AACA;AACA,+CAA+C,sCAAsC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,uCAAuC,EAAE,sBAAsB,KAAK,qBAAqB;AACtI;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,uBAAuB,wBAAwB;AAC9F;AACA;AACA,oCAAoC,6BAA6B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,4BAA4B;AAC5B;AACA,0CAA0C,gCAAgC;AAC1E;AACA;AACA;;;;;;;;;;;;;;;;;AChT+B;AACM;AACrC;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB;AACA;AACA,0BAA0B;AAC1B,gCAAgC;AAChC,mEAAmE;AACnE;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,4CAA4C,UAAU,IAAI,UAAU,UAAU,IAAI,iBAAiB;AACnG,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,oDAAoD;AACpD,oDAAoD;AACpD;AACA;AACA;AACA,yBAAyB,4BAA4B;AACrD;AACA,yBAAyB,6BAA6B;AACtD;AACA,yBAAyB,2BAA2B;AACpD;AACA,yBAAyB,8BAA8B;AACvD;AACA,yBAAyB,0BAA0B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA,gBAAgB,mBAAmB,wBAAwB,eAAe;AAC1E;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,aAAa;AAClD,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA,+CAA+C;AAC/C;AACA,8CAA8C,aAAa,IAAI;AAC/D;AACA;AACA,8DAA8D,4DAA4D;AAC1H,iBAAiB;AACjB;AACA;AACA,YAAY;AACZ;AACA;;;;;;UClNA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;UENA;UACA;UACA;UACA","sources":["webpack://SpinItUp/webpack/universalModuleDefinition","webpack://SpinItUp/./lib/slice.js","webpack://SpinItUp/./lib/spinitup.js","webpack://SpinItUp/./lib/wheel.js","webpack://SpinItUp/webpack/bootstrap","webpack://SpinItUp/webpack/runtime/define property getters","webpack://SpinItUp/webpack/runtime/hasOwnProperty shorthand","webpack://SpinItUp/webpack/runtime/make namespace object","webpack://SpinItUp/webpack/before-startup","webpack://SpinItUp/webpack/startup","webpack://SpinItUp/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SpinItUp\"] = factory();\n\telse\n\t\troot[\"SpinItUp\"] = factory();\n})(typeof self !== 'undefined' ? self : this, () => {\nreturn ","import SpinItUp from \"./spinitup.js\";\r\n\r\n/**\r\n * Slice: Represents a single slice of the wheel.\r\n */\r\nexport default class Slice {\r\n    /**\r\n     * Creates an array of slices based on the segments and wheel size.\r\n     * Each slice corresponds to a segment of the wheel and includes\r\n     * its start and end angles, index, and associated data.\r\n     * \r\n     * @param {Array} segments - The segments for the wheel. Each segment contains data for the slice.\r\n     * @returns {Array<Slice>} - An array of Slice objects representing the slices of the wheel.\r\n     */\r\n    static create(segments) {\r\n        SpinItUp.log('Creating slices with segments:', segments);\r\n\r\n        const numberOfSlices = segments.length;\r\n        let currentAngle = 0; // Starting angle for the first slice\r\n        const slices = [];\r\n\r\n        segments.forEach((segment, index) => {\r\n            const sliceAngle = (1 / numberOfSlices) * 2 * Math.PI; // Calculate slice angle in radians\r\n            slices.push(new Slice(currentAngle, currentAngle + sliceAngle, index, segment)); // Create a Slice object\r\n            currentAngle += sliceAngle; // Update current angle for the next slice\r\n        });\r\n\r\n        return slices;\r\n    }\r\n\r\n    /**\r\n     * Determines which slice was clicked on based on the user's click event.\r\n     * This method calculates the angle and distance from the center of the wheel\r\n     * to find the slice corresponding to the clicked position.\r\n     * \r\n     * @param {MouseEvent} event - The mouse click event.\r\n     * @param {HTMLCanvasElement} canvas - The canvas element representing the wheel.\r\n     * @param {number} size - The size (diameter) of the wheel.\r\n     * @param {Array<Slice>} slices - The array of Slice objects.\r\n     * @returns {number|null} - The index of the clicked slice, or null if no slice was clicked.\r\n     */\r\n    static getClickedSliceIndex(event, canvas, size, slices) {\r\n        SpinItUp.log('Determining clicked slice based on event:', event);\r\n\r\n        // Get click coordinates relative to the canvas\r\n        const rect = canvas.getBoundingClientRect();\r\n        const x = event.clientX - rect.left - size / 2; // X coordinate relative to center\r\n        const y = event.clientY - rect.top - size / 2; // Y coordinate relative to center\r\n        const distanceFromCenter = Math.sqrt(x * x + y * y); // Distance from the center of the wheel\r\n\r\n        // Check if click is outside the wheel\r\n        if (distanceFromCenter > size / 2) {\r\n            SpinItUp.log('Click outside the wheel.');\r\n            return null; // Return null if clicked outside the wheel\r\n        }\r\n\r\n        // Calculate the angle of the click in radians\r\n        const angle = Math.atan2(y, x);\r\n        const normalizedAngle = angle < 0 ? angle + 2 * Math.PI : angle; // Normalize angle to [0, 2Ï€]\r\n\r\n        // Find the slice corresponding to the click angle\r\n        for (const slice of slices) {\r\n            if (\r\n                normalizedAngle >= slice.startAngle &&\r\n                normalizedAngle < slice.endAngle\r\n            ) {\r\n                SpinItUp.log(`Clicked slice index: ${slice.index}`);\r\n                return slice.index;\r\n            }\r\n        }\r\n\r\n        SpinItUp.log('No slice found for the click event.');\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Constructs a Slice object representing a segment of the wheel.\r\n     * \r\n     * @param {number} startAngle - The starting angle of the slice in radians.\r\n     * @param {number} endAngle - The ending angle of the slice in radians.\r\n     * @param {number} index - The index of the slice (used to identify it).\r\n     * @param {Object} segment - The data associated with the slice, such as display text and appearance.\r\n     */\r\n    constructor(startAngle, endAngle, index, segment) {\r\n        SpinItUp.log('Creating Slice:', {\r\n            startAngle,\r\n            endAngle,\r\n            index,\r\n            segment,\r\n        });\r\n\r\n        this.startAngle = startAngle; // Start angle of the slice in radians\r\n        this.endAngle = endAngle; // End angle of the slice in radians\r\n        this.index = index; // Index of the slice\r\n        this.segment = segment; // Data associated with the slice\r\n    }\r\n\r\n    textPositions = {\r\n        /**\r\n         * Draws text from left to right.\r\n         */\r\n        'left-to-right': (context, text, x, y, angle) => {\r\n            context.translate(x, y); // Move to the specified position\r\n            context.rotate(angle); // Rotate the canvas for alignment\r\n            context.fillText(text, 0, 0); // Render the text\r\n            context.rotate(-angle); // Reset the rotation\r\n            context.translate(-x, -y); // Reset the position\r\n        },\r\n    \r\n        /**\r\n         * Draws text from right to left (reversed characters).\r\n         */\r\n        'right-to-left': (context, text, x, y, angle) => {\r\n            context.translate(x, y);\r\n            context.rotate(angle);\r\n            context.fillText(text.split(\"\").reverse().join(\"\"), 0, 0); // Reverse the text\r\n            context.rotate(-angle);\r\n            context.translate(-x, -y);\r\n        },\r\n    \r\n        /**\r\n         * Draws text vertically from top to bottom.\r\n         */\r\n        'top-to-bottom': (context, text, x, y) => {\r\n            context.translate(x, y);\r\n            text.split(\"\").forEach((char, i) => {\r\n                context.fillText(char, 0, i * 18); // Draw each character vertically\r\n            });\r\n            context.translate(-x, -y);\r\n        },\r\n    \r\n        /**\r\n         * Draws text vertically from bottom to top (reversed order).\r\n         */\r\n        'bottom-to-top': (context, text, x, y) => {\r\n            context.translate(x, y);\r\n            text.split(\"\").reverse().forEach((char, i) => {\r\n                context.fillText(char, 0, -i * 18); // Reverse and draw vertically\r\n            });\r\n            context.translate(-x, -y);\r\n        },\r\n    \r\n        /**\r\n         * Draws text diagonally from top-left to bottom-right.\r\n         */\r\n        'diagonal-top-left': (context, text, x, y, angle) => {\r\n            context.translate(x, y); // Move to the specified position\r\n            context.rotate(angle - Math.PI / 4); // Adjust angle for diagonal alignment\r\n            context.fillText(text, 0, 0); // Render the text\r\n            context.rotate(-(angle - Math.PI / 4)); // Reset the rotation\r\n            context.translate(-x, -y); // Reset the position\r\n        },\r\n    };\r\n    \r\n    /**\r\n     * Draws the slice on the provided canvas context.\r\n     */\r\n    draw(context, size, isSelected) {\r\n        SpinItUp.log('Drawing slice:', {\r\n            index: this.index,\r\n            isSelected,\r\n        });\r\n    \r\n        const {\r\n            backgroundColor = 'transparent',\r\n            color = '#000000',\r\n            fontSize = 20,\r\n            borderColor = 'transparent',\r\n            borderWidth = 2,\r\n            textOffset = 0.7,\r\n            textAlign = 'center',\r\n            textBaseline = 'middle',\r\n            padding = 0,\r\n            text = \"\",\r\n            textPosition = \"left-to-right\",\r\n            textAngleOffset = 0\r\n        } = this.segment;\r\n        \r\n        const maxLength = 16; // Maximum text length\r\n        const baseFontSize = 15; // Base font size for 16 characters\r\n        \r\n        // Slice the text to a maximum of maxLength characters\r\n        const actualText = text.slice(0, maxLength);\r\n\r\n        SpinItUp.log('Drawing slice: actualText', {actualText});\r\n        \r\n        const calculateProportionalFontSize = () => {\r\n            // Calculate the scaling factor based on actualText length\r\n            const scaleFactor = maxLength / Math.max(actualText.length, 1); // Prevent division by zero\r\n            \r\n            // Calculate new font size\r\n            let newFontSize = baseFontSize * scaleFactor;\r\n            \r\n            // Cap the maximum font size at fontSize (provided in props)\r\n            return Math.min(newFontSize, fontSize);\r\n        };\r\n        \r\n        const calculatedFontSize = calculateProportionalFontSize();\r\n\r\n        context.beginPath();\r\n        context.moveTo(size / 2, size / 2);\r\n        context.arc(size / 2, size / 2, size / 2, this.startAngle, this.endAngle);\r\n        context.closePath();\r\n    \r\n        context.fillStyle = isSelected ? 'yellow' : backgroundColor;\r\n        context.fill();\r\n    \r\n        if (borderWidth > 0) {\r\n            context.lineWidth = borderWidth;\r\n            context.strokeStyle = borderColor;\r\n            context.stroke();\r\n        }\r\n    \r\n        const textAngle = this.startAngle + (this.endAngle - this.startAngle) / 2;\r\n        const radius = size / 2.5 - padding;\r\n        const textX = size / 2 + radius * Math.cos(textAngle) * textOffset;\r\n        const textY = size / 2 + radius * Math.sin(textAngle) * textOffset;\r\n    \r\n        context.fillStyle = color;\r\n        context.font = `${calculatedFontSize}px Arial`;\r\n        context.textAlign = textAlign;\r\n        context.textBaseline = textBaseline;\r\n    \r\n        if (this.textPositions[textPosition]) {\r\n            this.textPositions[textPosition](context, actualText, textX, textY, textAngle + textAngleOffset);\r\n        } else {\r\n            this.textPositions['left-to-right'](context, actualText, textX, textY, textAngle + textAngleOffset);\r\n        }\r\n    }\r\n    \r\n    \r\n}\r\n","import Slice from \"./slice.js\";\r\nimport Wheel from \"./wheel.js\";\r\n\r\n// Define pin positions with their corresponding rotation angles in degrees\r\nconst pinPositions = {\r\n    top: 90,\r\n    right: 0,\r\n    bottom: -90,\r\n    left: 180,\r\n};\r\n\r\n/**\r\n * SpinItUp: A customizable Spin-the-Wheel class.\r\n * Author: Deepansu Mor (https://github.com/deepansumor)\r\n */\r\n\r\n// Main SpinItUp class\r\nexport default class SpinItUp {\r\n    /**\r\n     * Constructor for initializing the SpinItUp class.\r\n     * @param {HTMLElement} elem - The HTML element representing the wheel.\r\n     * @param {Object} options - Configuration options for the wheel.\r\n     */\r\n    constructor(elem, options = {}) {\r\n        SpinItUp.log('Initializing SpinItUp instance with element:', elem, 'and options:', options);\r\n\r\n        if (!(elem instanceof HTMLElement)) {\r\n            throw new Error('Element is not a valid HTMLElement');\r\n        }\r\n\r\n        this.elem = elem;\r\n\r\n        // Define possible states\r\n        this.states = {\r\n            SPINNING: 'spinning',\r\n            STOPPED: 'stopped',\r\n            FINISHED: 'finished',\r\n            ERROR: 'error',\r\n            INITIALIZED:\"init\"\r\n        };\r\n\r\n        // Default options and user-provided overrides\r\n        this.options = {\r\n            spins: 2,\r\n            easing: 'linear',\r\n            callback: (type, data) => SpinItUp.log(type, data),\r\n            segments: Array.from({ length: 6 }, (_, i) => ({ segment: i + 1 })),\r\n            stopAt: null,\r\n            direction: 'clockwise',\r\n            rotate: 0,\r\n            pin: {\r\n                position: \"top\",\r\n            },\r\n            mode: \"view\",\r\n            ...options,\r\n            type: this.elem instanceof HTMLImageElement ? \"image\" : \"draw\",\r\n        };\r\n\r\n        this.options.pin.offsets = options.pin.offsets || {\r\n            \"--pin-offset-x\": \"0%\",\r\n            \"--pin-offset-y\": \"25%\"\r\n        };\r\n\r\n        this.directions = ['clockwise', 'anti-clockwise'];\r\n        this.key = `spin-it-up-${Math.random().toString(36).substring(7)}`;\r\n        SpinItUp.log('Generated unique key for instance:', this.key);\r\n\r\n        this.pinOffset = pinPositions[this.options.pin.position] != undefined ? pinPositions[this.options.pin.position] : pinPositions.top;\r\n        SpinItUp.log(this.pinOffset);\r\n\r\n\r\n        this.elem.style.overflow = 'hidden';\r\n        this.options.rotate = 0;\r\n        this.state = this.states.STOPPED;\r\n\r\n        ((async () => {\r\n            await this.draw();\r\n            SpinItUp.log('SpinItUp instance initialized.');\r\n            this.callback(this.states.INITIALIZED,{})\r\n        })());\r\n\r\n    }\r\n\r\n    static log() {\r\n        this.ENABLE_LOG = typeof ENABLE_LOG == \"undefined\" || ENABLE_LOG;\r\n        this.ENABLE_LOG && console.log(\"[SPIN-IT-UP]\", ...arguments);\r\n    }\r\n    /**\r\n     * Generates a unique class name based on the instance key.\r\n     * @param {string} name - The base name for the class.\r\n     * @returns {string} - The generated class name.\r\n     */\r\n    getClassName(name) {\r\n        return `${this.key}-${name}`;\r\n    }\r\n\r\n    /**\r\n     * Draws the wheel based on the type (image or canvas).\r\n     */\r\n    async draw() {\r\n        SpinItUp.log('Drawing wheel in type:', this.options.type);\r\n        if (this.options.type === \"image\") {\r\n            await this.drawImageBackground();\r\n        } else {\r\n            this.drawCanvas();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the wheel using an image background.\r\n     */\r\n    async drawImageBackground() {\r\n        SpinItUp.log('Drawing wheel using image background.');\r\n        const image = new Image();\r\n        image.src = this.elem.src;\r\n\r\n        await new Promise((resolve, reject) => {\r\n            image.onload = resolve;\r\n            image.onerror = reject;\r\n        });\r\n\r\n        const canvasWheel = new Wheel(this.elem, this.options);\r\n        const slices = Slice.create(this.options.segments);\r\n\r\n        /**\r\n         * Redraws the slices with the selected slice highlighted.\r\n         * @param {number} selectedSliceIndex - The index of the selected slice.\r\n         */\r\n        const drawAllSlices = async (selectedSliceIndex) => {\r\n            await canvasWheel.drawImage(image); // Redraw image\r\n            canvasWheel.drawSlices(slices, selectedSliceIndex);\r\n        };\r\n\r\n        // Add event listener for clicks\r\n        canvasWheel.addClickListener(slices, drawAllSlices);\r\n\r\n        drawAllSlices();\r\n\r\n        this.canvas = canvasWheel.canvas;\r\n\r\n        SpinItUp.log(this.canvas);\r\n\r\n        if (this.options.mode == \"edit\") {\r\n            this.selectSlice = (index) => canvasWheel.selectSlice(index, drawAllSlices);\r\n            this.updateSlice = (index,data) => {\r\n                this.options.segments[index] = data;\r\n                slices[index].segment = data;\r\n                slices[index].draw(canvasWheel.context,canvasWheel.size,false);\r\n            };\r\n            this.selectSlice(0);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Draws the wheel using a canvas element.\r\n     */\r\n    drawCanvas() {\r\n        SpinItUp.log('Drawing wheel using canvas.');\r\n        const canvasWheel = new Wheel(this.elem, this.options);\r\n        const slices = Slice.create(this.options.segments);\r\n\r\n        /**\r\n         * Redraws the slices with the selected slice highlighted.\r\n         * @param {number} selectedSliceIndex - The index of the selected slice.\r\n         */\r\n        const drawAllSlices = (selectedSliceIndex) => canvasWheel.drawSlices(slices, selectedSliceIndex);\r\n        canvasWheel.addClickListener(slices, drawAllSlices);\r\n        drawAllSlices();\r\n\r\n        this.canvas = canvasWheel.canvas;\r\n\r\n        SpinItUp.log(this.canvas);\r\n\r\n        if (this.options.mode == \"edit\") {\r\n            this.selectSlice = (index) => canvasWheel.selectSlice(index, drawAllSlices);\r\n            this.updateSlice = (index,data) => {\r\n                this.options.segments[index] = data;\r\n                slices[index].draw(canvasWheel.context,canvasWheel.size,false,data)\r\n            };\r\n            this.selectSlice(0);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Updates the stop angle based on the segment count and target segment.\r\n     */\r\n    updateStopAngle() {\r\n        const slice = 360 / this.options.segments.length;\r\n        this.stopAngle = this.minMax(\r\n            this.options.stopAt * slice - slice + slice * 0.25,\r\n            this.options.stopAt * slice - slice * 0.25\r\n        ) + this.pinOffset;\r\n        SpinItUp.log(`stopAngle`, this.stopAngle);\r\n    }\r\n\r\n    /**\r\n     * Generates a random number within a given range.\r\n     * @param {number} min - The minimum value.\r\n     * @param {number} max - The maximum value.\r\n     * @returns {number} - The generated random number.\r\n     */\r\n    minMax(min, max) {\r\n        return Math.floor(Math.random() * (max - min + 1) + min);\r\n    }\r\n\r\n    /**\r\n     * Creates the CSS animation for spinning the wheel.\r\n     */\r\n    style() {\r\n        SpinItUp.log('Generating CSS keyframe animation.');\r\n        this.updateStopAngle();\r\n\r\n        let deg = 360 * this.options.spins;\r\n        if (!this.directions.includes(this.options.direction)) {\r\n            this.options.direction = 'clockwise';\r\n        }\r\n\r\n        if (this.options.direction === \"random\") {\r\n            const randomIndex = Math.floor(Math.random() * this.directions.length);\r\n            this.options.direction = this.directions[randomIndex];\r\n        }\r\n\r\n        if (this.options.direction === \"clockwise\") {\r\n            deg = deg + (360 - this.stopAngle);\r\n        } else if (this.options.direction === \"anti-clockwise\") {\r\n            deg = -(deg + this.stopAngle);\r\n        }\r\n\r\n        this.options.speed = deg / this.options.duration;\r\n\r\n        const style = document.createElement('style');\r\n        style.innerHTML = `@keyframes ${this.getClassName('animation-rotate')} { 100% { transform: rotate(${deg}deg); } }`;\r\n        document.head.appendChild(style);\r\n    }\r\n\r\n    /**\r\n     * Starts the spinning of the wheel.\r\n     */\r\n    async start() {\r\n        if (!this.options.segments[this.options.stopAt - 1]) {\r\n            throw new Error(`stopAt must be a valid Number within the segments array 1 - ${this.options.segments.length}`);\r\n        }\r\n        if (this.state != this.states.STOPPED && this.state != this.states.FINISHED) {\r\n            return this.callback(this.state, { message: 'Wheel is already spinning' });\r\n        }\r\n        this.state = this.states.SPINNING;\r\n        this.#spin();\r\n    }\r\n\r\n    /**\r\n     * Executes the spinning logic with animations.\r\n     * @private\r\n     */\r\n    #spin() {\r\n        this.style();\r\n        this.callback(this.state);\r\n        this.canvas.style.animation = \"none\";\r\n        // a delay\r\n        setTimeout(() => {\r\n            this.canvas.style.animation = `${this.getClassName('animation-rotate')} ${this.options.duration}ms ${this.options.easing} 1 forwards`;\r\n            this.timeout = setTimeout(() => this.stop(), this.options.duration);\r\n            this.options._mode = this.options.mode;\r\n            this.options.mode = null;\r\n        }, 0);\r\n    }\r\n\r\n    /**\r\n     * Stops the spinning of the wheel and determines the winning segment.\r\n     */\r\n    stop() {\r\n        if (this.state !== this.states.SPINNING && this.state !== this.states.FINISHED) {\r\n            return this.callback(this.state, { message: 'Cannot stop; wheel is not spinning' });\r\n        }\r\n        this.state = this.states.FINISHED;\r\n        this.callback(this.state, { ...this.getWinningSegment() });\r\n        clearTimeout(this.timeout);\r\n        this.options.mode = this.options._mode;\r\n        this.canvas.style.animation = \"none\";\r\n    }\r\n\r\n    reset() {\r\n        this.canvas.style.animation = \"none\";\r\n        this.stop();\r\n    }\r\n\r\n    /**\r\n     * Retrieves the winning segment based on the stop position.\r\n     * @returns {Object} - The winning segment.\r\n     */\r\n    getWinningSegment() {\r\n        let index = this.options.stopAt - 1;\r\n        return { index, segment: this.options.segments[index] };\r\n    }\r\n\r\n    /**\r\n     * Executes the callback function with the specified type and data.\r\n     * @param {string} type - The type of event (e.g., state change).\r\n     * @param {Object} data - Additional data to pass to the callback.\r\n     */\r\n    callback(type, data = {}) {\r\n        if (typeof this.options.callback === 'function') {\r\n            this.options.callback(type, { ...data, timestamp: Date.now() });\r\n        }\r\n    }\r\n}\r\n","import Slice from \"./slice.js\";\r\nimport SpinItUp from \"./spinitup.js\";\r\n\r\n\r\n\r\n\r\n// Wheel class to handle canvas-specific logic and manage the wheel's behavior\r\nexport default class Wheel {\r\n    /**\r\n     * Constructs the Wheel instance, initializes the canvas, and sets its properties.\r\n     * \r\n     * @param {HTMLElement} elem - The DOM element where the wheel will be rendered.\r\n     * @param {Object} options - Configuration options for the wheel, such as rotation and pin placement.\r\n     */\r\n    constructor(elem, options) {\r\n        this.elem = elem; // The element to replace with the wheel\r\n        this.options = options; // Options for customizing the wheel\r\n        this.size = Math.min(elem.offsetWidth, elem.offsetHeight); // Set wheel size to the smaller of the element's width or height\r\n\r\n        // Create a canvas for rendering the wheel\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = canvas.height = this.size; // Set canvas dimensions to the wheel size\r\n\r\n        // Create a container to hold the canvas and apply styles\r\n        const container = document.createElement('div');\r\n        container.style.cssText = `width: ${this.size}px; height: ${this.size}px; overflow: hidden;position:relative`;\r\n        container.appendChild(canvas); // Add canvas to the container\r\n        container.className = \"spin-it-up-container\";\r\n        // Get the 2D rendering context for the canvas\r\n        this.context = canvas.getContext('2d');\r\n\r\n        // Replace the original element with the canvas container\r\n        elem.parentElement.replaceChild(container, elem);\r\n        this.elem = this.canvas = canvas; // Update the element reference to the canvas\r\n\r\n        // Set the wheel shape to a circle\r\n        this.elem.style.borderRadius = '50%';\r\n\r\n\r\n        // Optionally, set the pin position\r\n        this.setPin();\r\n    }\r\n\r\n    //  get edge of canvas to place pin\r\n    getCircleEdge(position) {\r\n        const rect = this.canvas.getBoundingClientRect(); // Get the bounding box of the element\r\n        const centerX = rect.left + rect.width / 2; // Calculate the center X of the circle\r\n        const centerY = rect.top + rect.height / 2; // Calculate the center Y of the circle\r\n\r\n        switch (position) {\r\n            case 'left':\r\n                return { x: rect.left, y: centerY }; // Left edge\r\n            case 'right':\r\n                return { x: rect.right, y: centerY }; // Right edge\r\n            case 'top':\r\n                return { x: centerX, y: rect.top }; // Top edge\r\n            case 'bottom':\r\n                return { x: centerX, y: rect.bottom }; // Bottom edge\r\n            case 'center':\r\n                return { x: centerX, y: centerY }; // Center\r\n            default:\r\n                throw new Error('Invalid position. Valid values are left, right, top, bottom, center.');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the position of the pin on the wheel based on the options provided.\r\n     * \r\n     * @example\r\n     * this.setPin({ position: \"top-right\" });\r\n     */\r\n    setPin() {\r\n        const { position = \"top\" } = this.options.pin || { offsets: {} }; // Get the pin position from options or use \"top\" by default\r\n\r\n        const pin = document.querySelector(\".wheel-section__pin\");\r\n        let edges = this.getCircleEdge(position);\r\n        pin.style.top = `${edges.y}px`;\r\n        pin.style.left = `${edges.x}px`;\r\n\r\n        let circleEdges = this.getCircleEdge(\"center\");\r\n\r\n        const circle = document.querySelector(\".wheel-section__center\");\r\n        circle.style.top = `${circleEdges.y}px`;\r\n        circle.style.left = `${circleEdges.x}px`;\r\n\r\n        // document.body.style.setProperty(\"--pin-offset-x\", offsetX || 0);\r\n        // document.body.style.setProperty(\"--pin-offset-y\", offsetY || 0);\r\n    }\r\n\r\n    /**\r\n  * Draws a high-resolution image on the canvas wheel, ensuring it fits perfectly.\r\n  * \r\n  * @param {HTMLImageElement} image - The image to draw on the wheel.\r\n  */\r\n    async drawImage(image) {\r\n\r\n        // Get the device pixel ratio, falling back to 1 if unavailable\r\n        const dpr = window.devicePixelRatio || 1;\r\n\r\n        // Get the CSS dimensions of the canvas\r\n        const displayWidth = this.size;\r\n        const displayHeight = this.size;\r\n\r\n        // Set the canvas buffer size to match the display size multiplied by DPR\r\n        this.canvas.width = displayWidth * dpr;\r\n        this.canvas.height = displayHeight * dpr;\r\n\r\n        // Set the canvas CSS size to maintain visual dimensions\r\n        this.canvas.style.width = `${displayWidth}px`;\r\n        this.canvas.style.height = `${displayHeight}px`;\r\n\r\n        // Scale all future drawing operations by the DPR\r\n        this.context.scale(dpr, dpr);\r\n\r\n        // Enable image smoothing for better quality\r\n        this.context.imageSmoothingEnabled = true;\r\n        this.context.imageSmoothingQuality = 'high';\r\n\r\n        // Calculate the aspect ratios\r\n        const canvasAspectRatio = displayWidth / displayHeight;\r\n        const imageAspectRatio = image.width / image.height;\r\n\r\n        let drawWidth = displayWidth;\r\n        let drawHeight = displayHeight;\r\n        let x = 0;\r\n        let y = 0;\r\n\r\n        // Determine dimensions to cover the canvas while maintaining aspect ratio\r\n        if (imageAspectRatio > canvasAspectRatio) {\r\n            // Image is wider than canvas\r\n            drawHeight = displayHeight;\r\n            drawWidth = drawHeight * imageAspectRatio;\r\n            x = (displayWidth - drawWidth) / 2;\r\n        } else {\r\n            // Image is taller than canvas\r\n            drawWidth = displayWidth;\r\n            drawHeight = drawWidth / imageAspectRatio;\r\n            y = (displayHeight - drawHeight) / 2;\r\n        }\r\n\r\n        // Clear the canvas before drawing\r\n        // this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n        // Draw the image\r\n        this.context.drawImage(\r\n            image,\r\n            x, y,\r\n            drawWidth, drawHeight\r\n        );\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Draws all slices of the wheel on the canvas, optionally highlighting a selected slice.\r\n     * \r\n     * @param {Array<Slice>} slices - The array of Slice objects to draw.\r\n     * @param {number|null} selectedSliceIndex - The index of the slice to highlight (if any).\r\n     */\r\n    drawSlices(slices, selectedSliceIndex = null) {\r\n        slices.forEach(slice =>\r\n            slice.draw(this.context, this.size, slice.index === selectedSliceIndex)\r\n        );\r\n    }\r\n\r\n    // Select the slice by index\r\n    selectSlice(index, drawAllSlices) {\r\n        const centerX = this.size / 2; // X-coordinate of the wheel's center\r\n        const centerY = this.size / 2; // Y-coordinate of the wheel's center\r\n\r\n        // Clear the canvas\r\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n        // Restore the canvas state after clearing\r\n        this.context.save();\r\n        this.context.translate(centerX, centerY); // Move origin back to the center\r\n        this.context.rotate((this.options.rotate * Math.PI) / 180); // Rotate to the specified angle\r\n        this.context.restore();\r\n\r\n        // Redraw slices with the clicked slice highlighted\r\n        drawAllSlices(index);\r\n    }\r\n\r\n    /**\r\n     * Adds a click event listener to the canvas to detect clicks on slices.\r\n     * When a slice is clicked, it redraws the wheel and highlights the selected slice.\r\n     * \r\n     * @param {Array<Slice>} slices - The array of Slice objects representing the wheel.\r\n     * @param {Function} drawAllSlices - Callback to redraw all slices with an updated selection.\r\n     */\r\n    addClickListener(slices, drawAllSlices) {\r\n        // this.canvas.addEventListener('click', (event) => {\r\n\r\n        //     if (this.options.mode != \"edit\") return;\r\n        //     // Determine which slice was clicked\r\n        //     const clickedIndex = Slice.getClickedSliceIndex(event, this.canvas, this.size, slices);\r\n\r\n        //     if (isNaN(clickedIndex)) return; // Ignore clicks outside the wheel\r\n\r\n        //     this.selectSlice(clickedIndex); // Highlight the selected slice\r\n\r\n        //     SpinItUp.log(`Slice clicked: ${clickedIndex}`); // Log the index of the clicked slice\r\n\r\n        //     try {\r\n        //         this.options.callback(\"SEGMENT_CLICKED\", { index: clickedIndex, segment: slices[clickedIndex].segment })\r\n        //     } catch (error) {\r\n\r\n        //     }\r\n        // });\r\n    }\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./lib/spinitup.js\");\n",""],"names":[],"sourceRoot":""}